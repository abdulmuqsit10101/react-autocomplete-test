# Solution

## Answer 1: Difference between Component and PureComponent

**Component**: This class does not implement `shouldComponentUpdate`, so it will be updated when its parent class is updated, even if the component or state has not changed. This can cause unnecessary re-renders and performance issues in large applications.

**PureComponent**: This class implements a shallow comparison of props and state in `shouldComponentUpdate`. It re-renders only when props or state changes. This is optimized to avoid unnecessary re-rendering.

Examples where it might break your application:

Suppose you have a component that receives an array of objects and renders them. If the parent component frequently provides new arrays (even with the same content), the child component will re-render each time, leading to poor performance.

Switching to `PureComponent` in this case can optimize performance by checking if the reference to the array has changed and re-rendering only if necessary, thus improving performance when the same data is frequently updated.

## Answer 2: Context + shouldComponentUpdate

Using Context and `shouldComponentUpdate` together can be dangerous because `shouldComponentUpdate` cannot access changes in Context. This can lead to unexpected behavior and make it challenging to manage updates properly.

## Answer 3: 3 Ways to Pass Data from Child to Parent

1. **Callback Function**: Define a callback function in the parent component and pass it as a prop to the child component. The child component can call this function to pass data back to the parent.

2. **Context API**: Utilize React's Context API to share data between components. The parent component creates a context and provides functions to manipulate the shared data. Child components can access and modify the data using these provided functions. This approach is suitable for sharing data between components at different levels of the component tree.

3. **Redux**: If your application uses Redux for state management, you can dispatch actions from child components to update the global state. Parent components can subscribe to the store and receive updates when the state changes. This method is ideal for managing global state where many components need access and updates.

## Answer 4: 2 Ways to Prevent Components from Re-rendering

1. **Using PureComponent**: React provides a `PureComponent` class that performs a shallow comparison of props and state before deciding whether to re-render. If no changes are found, the component won't re-render. This can improve performance for components that frequently receive prop changes.

2. **Memoization**: To prevent re-rendering when unnecessary, you can use memoization techniques like the `useMemo` hook for functional components or the `shouldComponentUpdate` method for class components. These techniques allow you to cache and reuse the results of calculations or inputs, avoiding unnecessary re-renders.

## Answer 5: What is a Fragment and Why Do We Need It?

**Fragment** is a feature in React that allows you to group multiple elements without adding an extra parent element to the DOM. Fragments help improve the structure and semantics of the HTML generated by your components.

Example where it might break your app:

Avoid using fragments excessively within a single component, as it can lead to less readable code. Additionally, if fragments are nested too deeply, it may become challenging to debug or style the components effectively.

## Answer 6: 3 Examples of the HOC Pattern

1. **Authentication HOC**: An HOC that checks if a user is authenticated and, if so, renders the wrapped component; otherwise, it redirects to a login page. It's useful for protecting routes in a web application.

2. **Data Fetching HOC**: An HOC that fetches data from an API or other sources and passes it as props to the wrapped component. This helps fetch data for different components, avoiding redundant API calls.

3. **Logging HOC**: An HOC that logs lifecycle events and props of a component for debugging purposes. It provides insights into component behavior during development.

## Answer 7: Difference in Handling Exceptions in Promises, Callbacks, and async...await

- **Promises**: Promises use `.then()` and `.catch()` methods to handle resolved and rejected states. Errors can be caught using `.catch()` at the end of a promise chain.

```javascript
fetchData()
  .then((data) => {
    // Handle resolved state
  })
  .catch((error) => {
    // Handle rejected state
  });
```

- **Callbacks**: Callbacks rely on passing a callback function as an argument, which gets invoked when an operation completes, including any errors. Error handling in callbacks often involves checking for errors in the callback function's parameters.

```javascript
fetchData((error, data) => {
  if (error) {
    // Handle error
  } else {
    // Handle success
  }
});
```

- **async...await**: `async...await` is a more structured and synchronous-like way of handling asynchronous operations. It uses try-catch blocks to handle exceptions, making error handling more readable.

```javascript
async function fetchData() {
  try {
    const response = await fetch(url);
    const data = await response.json();
    // Handle success
  } catch (error) {
    // Handle error
  }
}
```

## Answer 8: How Many Arguments Does setState Take and Why Is It Async?

`setState` takes two arguments:

1. State Object: The first argument is an object representing the partial state changes you want to make.

2. Callback Function (Optional): The second argument is an optional callback function that executes after the state has been updated and the component re-renders.

`setState` is asynchronous to optimize performance. By batching state updates, React minimizes the number of re-renders and DOM updates. Batching prevents multiple state changes in quick succession from causing unnecessary intermediate re-renders.

## Answer 9: Steps to Migrate a Class to Function Component

1. Import React.
2. Remove the class definition, including the `extends React.Component` part.
3. Copy state and lifecycle methods you want to retain.
4. Convert class state to functional component state using the `useState` hook.
5. Copy event handlers.
6. Convert lifecycle methods to the `useEffect` hook.
7. Update the render method; remove it entirely.
8. Handle props directly as parameters in the function.
9. Remove the constructor and `this` references.
10. Test and refactor your functional component.
11. Remove any leftover code no longer needed.
12. Replace class component usage with the functional component.

## Answer 10: Ways to Use Styles with Components

1. **Inline Styles**: Apply styles directly to JSX elements using the `style` attribute by creating a JavaScript object with CSS properties and values.

2. **CSS Classes**: Assign CSS classes to elements by defining CSS classes in separate .css files and applying them to JSX elements.

3. **CSS Modules**: Use CSS Modules to scope CSS locally to a component, preventing style conflicts and providing better encapsulation. Typically used with build tools like Webpack.

4. **Styled Components**: Utilize libraries like `styled-components` to define styled components using tagged template literals, encapsulating styles within components.

## Answer 11: How to Render an HTML String from the Server

To render an HTML string from the server:

1. **Sanitize the HTML** using a library like DOMPurify to remove potentially harmful content.
2. Create a React component that utilizes the `dangerouslySetInnerHTML` attribute to render the sanitized HTML.
3. Pass the sanitized HTML string as a prop to the component and set it using `dangerouslySetInnerHTML`.

```javascript
import DOMPurify from 'dompurify';

function RenderHtml({ htmlString }) {
  // Sanitize the HTML string
  const sanitizedHtml = DOMPurify.sanitize(htmlString);

  return <div dangerouslySetInnerHTML={{ __html: sanitizedHtml }} />;
}

// Usage
const htmlString = '<p>This is <strong>HTML</strong> content.</p>';
<RenderHtml htmlString={htmlString} />;
